import pandas as pd
import numpy as np
from scipy.stats import norm

def amostra_estratificada(df, coluna_estratificacao, confianca=0.95, margem_erro=0.05):
    """
    Calcula uma amostra estratificada de um DataFrame baseada em nível de confiança e margem de erro.
    
    Parâmetros:
    - df: DataFrame pandas
    - coluna_estratificacao: nome da coluna para estratificação
    - confianca: nível de confiança (default: 0.95 = 95%)
    - margem_erro: margem de erro (default: 0.05 = 5%)
    
    Retorna:
    - DataFrame com a amostra estratificada
    """
    
    # Calcula o valor Z para o nível de confiança
    z_score = norm.ppf(1 - (1 - confianca) / 2)
    
    # Calcula o tamanho da amostra total necessária
    # Usando fórmula: n = (Z² × p × (1-p)) / E²
    # Assumindo p = 0.5 (caso mais conservador)
    p = 0.5
    n_total = (z_score**2 * p * (1-p)) / (margem_erro**2)
    n_total = int(np.ceil(n_total))
    
    # Calcula os tamanhos dos estratos
    estratos = df[coluna_estratificacao].value_counts()
    proporcoes = estratos / len(df)
    
    # Calcula o tamanho da amostra para cada estrato
    tamanhos_amostra = {}
    for categoria, proporcao in proporcoes.items():
        tamanho_estrato = int(np.ceil(n_total * proporcao))
        # Garante que não exceda o tamanho do estrato
        tamanho_estrato = min(tamanho_estrato, estratos[categoria])
        tamanhos_amostra[categoria] = tamanho_estrato
    
    # Realiza a amostragem estratificada
    amostras = []
    for categoria, tamanho in tamanhos_amostra.items():
        estrato = df[df[coluna_estratificacao] == categoria]
        if len(estrato) >= tamanho:
            amostra_estrato = estrato.sample(n=tamanho, random_state=42)
            amostras.append(amostra_estrato)
    
    # Concatena todas as amostras
    amostra_final = pd.concat(amostras, ignore_index=True)
    
    # Informações sobre a amostra
    print(f"Tamanho da população: {len(df)}")
    print(f"Tamanho da amostra: {len(amostra_final)}")
    print(f"Nível de confiança: {confianca*100}%")
    print(f"Margem de erro: {margem_erro*100}%")
    print("\nDistribuição por categoria:")
    for categoria, tamanho in tamanhos_amostra.items():
        print(f"  {categoria}: {tamanho} registros")
    
    return amostra_final

def amostra_estratificada_simples(df, coluna_estratificacao, tamanho_amostra):
    """
    Versão simplificada que aceita diretamente o tamanho da amostra.
    """
    estratos = df[coluna_estratificacao].value_counts()
    proporcoes = estratos / len(df)
    
    # Calcula o tamanho exato para cada estrato
    tamanhos_calculados = {}
    total_alocado = 0
    
    # Primeiro, calcula os tamanhos proporcionais
    for categoria, proporcao in proporcoes.items():
        tamanho_estrato = int(tamanho_amostra * proporcao)
        tamanho_estrato = min(tamanho_estrato, estratos[categoria])
        tamanhos_calculados[categoria] = tamanho_estrato
        total_alocado += tamanho_estrato
    
    # Ajusta para atingir o tamanho exato da amostra
    diferenca = tamanho_amostra - total_alocado
    categorias_ordenadas = sorted(proporcoes.items(), key=lambda x: x[1], reverse=True)
    
    # Distribui a diferença pelas categorias maiores
    for categoria, _ in categorias_ordenadas:
        if diferenca == 0:
            break
        if diferenca > 0 and tamanhos_calculados[categoria] < estratos[categoria]:
            incremento = min(diferenca, estratos[categoria] - tamanhos_calculados[categoria])
            tamanhos_calculados[categoria] += incremento
            diferenca -= incremento
        elif diferenca < 0 and tamanhos_calculados[categoria] > 0:
            decremento = min(-diferenca, tamanhos_calculados[categoria])
            tamanhos_calculados[categoria] -= decremento
            diferenca += decremento
    
    # Realiza a amostragem
    amostras = []
    for categoria, tamanho in tamanhos_calculados.items():
        if tamanho > 0:
            estrato = df[df[coluna_estratificacao] == categoria]
            amostra_estrato = estrato.sample(n=tamanho, random_state=42)
            amostras.append(amostra_estrato)
    
    return pd.concat(amostras, ignore_index=True)
